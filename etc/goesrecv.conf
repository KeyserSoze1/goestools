[demodulator]
# mode = "lrit"
# mode = "hrit"
source = "airspy"

# The demodulator stats publisher sends a JSON object that describes
# the state of the demodulator (gain, frequency correction, samples
# per symbol), for every block of samples.
[demodulator.stats_publisher]
bind = "tcp://0.0.0.0:6001"

[agc]
min = 1e0
max = 1e3

[source.sample_publisher]
bind = "tcp://0.0.0.0:5003"
send_buffer = 2097152

[clock_recovery.sample_publisher]
bind = "tcp://0.0.0.0:5002"
send_buffer = 2097152

[quantization.soft_bit_publisher]
bind = "tcp://0.0.0.0:5001"
send_buffer = 1048576

[decoder.packet_publisher]
bind = "tcp://0.0.0.0:5004"
send_buffer = 1048576

# The decoder stats publisher sends a JSON object for every packet it
# decodes (Viterbi corrections, Reed-Solomon corrections, etc.).
[decoder.stats_publisher]
bind = "tcp://0.0.0.0:6002"

# The monitor can log aggregated stats (counters, gauges, and
# histograms) to a statsd daemon. Because this uses UDP, you can keep
# this enabled even if you haven't setup a statsd daemon yet.
[monitor]
statsd_address = "udp4://localhost:8125"

# If you set the demodulator source to "nanomsg", goesrecv will read
# samples from a nanomsg socket (for example another instance of
# goesrecv). This allows for debugging and testing new demodulation
# code without having to interrupt your primary LRIT/HRIT feed.
#
# [nanomsg]
# connect = "tcp://1.2.3.4:5005"
# receive_buffer = 2097152
# sample_rate = 2400000

